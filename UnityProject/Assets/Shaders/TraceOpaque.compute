#pragma use_dxc

#pragma require Int64BufferAtomics
#pragma require Native16Bit

#pragma kernel CSMain

#pragma require inlineraytracing
#pragma only_renderers d3d11

#include "Shared.hlsl"
#include "RaytracingShared.hlsl"


RWTexture2D<float4> gOut_Debug;



struct TraceOpaqueResult
{
    float3 diffRadiance;
    float diffHitDist;

    float3 specRadiance;
    float specHitDist;
    
    
    float3 debug;

    #if( NRD_MODE == SH || NRD_MODE == DIRECTIONAL_OCCLUSION )
    float3 diffDirection;
    float3 specDirection;
    #endif
};


TraceOpaqueResult TraceOpaque( GeometryProps geometryProps0, MaterialProps materialProps0, uint2 pixelPos, float3x3 mirrorMatrix, float4 Lpsr )
{
    TraceOpaqueResult result = ( TraceOpaqueResult )0;
#if( NRD_MODE < OCCLUSION )
    result.specHitDist = NRD_FrontEnd_SpecHitDistAveraging_Begin( );
#endif

    float viewZ0 = Geometry::AffineTransform( gWorldToView, geometryProps0.X ).z;
    float roughness0 = materialProps0.roughness;

    // Material de-modulation ( convert irradiance into radiance )
    float3 diffFactor0, specFactor0;
    {
        float3 albedo, Rf0;
        BRDF::ConvertBaseColorMetalnessToAlbedoRf0( materialProps0.baseColor, materialProps0.metalness, albedo, Rf0 );

        NRD_MaterialFactors( materialProps0.N, geometryProps0.V, albedo, Rf0, materialProps0.roughness, diffFactor0, specFactor0 );

        // We can combine radiance ( for everything ) and irradiance ( for hair ) in denoising if material ID test is enabled
        if( geometryProps0.Has( FLAG_HAIR ) && NRD_NORMAL_ENCODING == NRD_NORMAL_ENCODING_R10G10B10A2_UNORM )
        {
            diffFactor0 = 1.0;
            specFactor0 = 1.0;
        }
    }

    // SHARC debug visualization
#if( USE_SHARC_DEBUG != 0 )
    HashGridParameters hashGridParams;
    hashGridParams.cameraPosition = gCameraGlobalPos.xyz;
    hashGridParams.sceneScale = SHARC_SCENE_SCALE;
    hashGridParams.logarithmBase = SHARC_GRID_LOGARITHM_BASE;
    hashGridParams.levelBias = SHARC_GRID_LEVEL_BIAS;

    SharcHitData sharcHitData;
    sharcHitData.positionWorld = GetGlobalPos( geometryProps0.X );
    sharcHitData.materialDemodulation = GetMaterialDemodulation( geometryProps0, materialProps0 );
    sharcHitData.normalWorld = geometryProps0.N;
    sharcHitData.emissive = materialProps0.Lemi;

    HashMapData hashMapData;
    hashMapData.capacity = SHARC_CAPACITY;
    hashMapData.hashEntriesBuffer = gInOut_SharcHashEntriesBuffer;

    SharcParameters sharcParams;
    sharcParams.gridParameters = hashGridParams;
    sharcParams.hashMapData = hashMapData;
    sharcParams.radianceScale = SHARC_RADIANCE_SCALE;
    sharcParams.enableAntiFireflyFilter = SHARC_ANTI_FIREFLY;
    sharcParams.accumulationBuffer = gInOut_SharcAccumulated;
    sharcParams.resolvedBuffer = gInOut_SharcResolved;

    #if( USE_SHARC_DEBUG == 2 )
        result.diffRadiance = HashGridDebugColoredHash( sharcHitData.positionWorld, hashGridParams );
    #else
        bool isValid = SharcGetCachedRadiance( sharcParams, sharcHitData, result.diffRadiance, true );

        // Highlight invalid cells
        // result.diffRadiance = isValid ?  result.diffRadiance : float3( 1.0, 0.0, 0.0 );
    #endif

    result.diffRadiance /= diffFactor0;

    return result;
#endif

    uint checkerboard = Sequence::CheckerBoard( pixelPos, gFrameIndex ) != 0;
    uint pathNum = gSampleNum << (gTracingMode == RESOLUTION_FULL ? 1 : 0);
    uint diffPathNum = 0;

    [loop]
    for( uint path = 0; path < pathNum; path++ )
    {
        GeometryProps geometryProps = geometryProps0;
        MaterialProps materialProps = materialProps0;

        float accumulatedHitDist = 0;
        float accumulatedDiffuseLikeMotion = 0;
        float accumulatedCurvature = 0;

        float3 Lsum = Lpsr.xyz;
        float3 pathThroughput = 1.0 - Lpsr.w;
        bool isDiffusePath = false;

        [loop]
        for( uint bounce = 1; bounce <= gBounceNum && !geometryProps.IsMiss( ); bounce++ )
        {
            //=============================================================================================================================================================
            // Origin point
            //=============================================================================================================================================================

            bool isDiffuse = false;
            float lobeTanHalfAngleAtOrigin = 0.0;
            {
                // Diffuse probability
                float diffuseProbability = EstimateDiffuseProbability( geometryProps, materialProps );

                float rnd = Rng::Hash::GetFloat( );
                if( gTracingMode == RESOLUTION_FULL_PROBABILISTIC && bounce == 1 && !gRR )
                {
                    // Clamp probability to a sane range to guarantee a sample in 3x3 ( or 5x5 ) area ( see NRD docs )
                    diffuseProbability = float( diffuseProbability != 0.0 ) * clamp( diffuseProbability, gMinProbability, 1.0 - gMinProbability );
                    rnd = Sequence::Bayer4x4( pixelPos, gFrameIndex ) + rnd / 16.0;
                }

                // Diffuse or specular?
                isDiffuse = rnd < diffuseProbability; // TODO: if "diffuseProbability" is clamped, "pathThroughput" should be adjusted too
                if( gTracingMode == RESOLUTION_FULL_PROBABILISTIC || bounce > 1 )
                    pathThroughput /= isDiffuse ? diffuseProbability : ( 1.0 - diffuseProbability );
                else
                    isDiffuse = gTracingMode == RESOLUTION_HALF ? checkerboard : ( path & 0x1 );

                // This is not needed in case of "RESOLUTION_FULL_PROBABILISTIC", since hair doesn't have diffuse component
                if( geometryProps.Has( FLAG_HAIR ) && isDiffuse )
                    break;

                // Importance sampling
                uint sampleMaxNum = 0;
                if( bounce == 1 && gDisableShadowsAndEnableImportanceSampling && NRD_MODE < OCCLUSION )
                    sampleMaxNum = PT_IMPORTANCE_SAMPLES_NUM * ( isDiffuse ? 1.0 : GetSpecMagicCurve( materialProps.roughness ) );
                sampleMaxNum = max( sampleMaxNum, 1 );

            #if( NRD_MODE < OCCLUSION )
                float2 rnd2 = Rng::Hash::GetFloat2( );
            #else
                uint2 blueNoisePos = pixelPos + uint2( Sequence::Weyl2D( 0.0, path * gBounceNum + bounce ) * ( BLUE_NOISE_SPATIAL_DIM - 1 ) );
                float2 rnd2 = GetBlueNoise( blueNoisePos, gTracingMode == RESOLUTION_HALF );
            #endif

                float3 ray = GenerateRayAndUpdateThroughput( geometryProps, materialProps, pathThroughput, sampleMaxNum, isDiffuse, rnd2, HAIR );

                // Special case for primary surface ( 1st bounce starts here )
                if( bounce == 1 )
                {
                    isDiffusePath = isDiffuse;

                    if( gTracingMode == RESOLUTION_FULL )
                        Lsum *= isDiffuse ? diffuseProbability : ( 1.0 - diffuseProbability );

                    // ( Optional ) Save sampling direction for the 1st bounce
                    #if( NRD_MODE == SH )
                        float3 psrRay = Geometry::RotateVectorInverse( mirrorMatrix, ray );

                        if( isDiffuse )
                            result.diffDirection += psrRay;
                        else
                            result.specDirection += psrRay;
                    #endif
                }

                // Abort tracing if the current bounce contribution is low
            #if( USE_RUSSIAN_ROULETTE == 1 )
                /*
                BAD PRACTICE:
                Russian Roulette approach is here to demonstrate that it's a bad practice for real time denoising for the following reasons:
                - increases entropy of the signal
                - transforms radiance into non-radiance, which is strictly speaking not allowed to be processed spatially (who wants to get a high energy firefly
                redistributed around surrounding pixels?)
                - not necessarily converges to the right image, because we do assumptions about the future and approximate the tail of the path via a scaling factor
                - this approach breaks denoising, especially REBLUR, which has been designed to work with pure radiance
                */

                // Nevertheless, RR can be used with caution: the code below tuned for good IQ / PERF tradeoff
                float russianRouletteProbability = Color::Luminance( pathThroughput );
                russianRouletteProbability = Math::Pow01( russianRouletteProbability, 0.25 );
                russianRouletteProbability = max( russianRouletteProbability, 0.01 );

                if( Rng::Hash::GetFloat( ) > russianRouletteProbability )
                    break;

                pathThroughput /= russianRouletteProbability;
            #else
                /*
                GOOD PRACTICE:
                - terminate path if "pathThroughput" is smaller than some threshold
                - approximate ambient at the end of the path
                - re-use data from the previous frame
                */

                if( PT_THROUGHPUT_THRESHOLD != 0.0 && Color::Luminance( pathThroughput ) < PT_THROUGHPUT_THRESHOLD )
                    break;
            #endif

                //=========================================================================================================================================================
                // Trace to the next hit
                //=========================================================================================================================================================

                float roughnessTemp = isDiffuse ? 1.0 : materialProps.roughness;
                lobeTanHalfAngleAtOrigin = roughnessTemp * roughnessTemp / ( 1.0 + roughnessTemp * roughnessTemp );

                float2 mipAndCone = GetConeAngleFromRoughness( geometryProps.mip, isDiffuse ? 1.0 : materialProps.roughness );
                geometryProps = CastRay( geometryProps.GetXoffset( geometryProps.N ), ray, 0.0, INF, mipAndCone, gWorldTlas, FLAG_NON_TRANSPARENT, PT_RAY_FLAGS );
                materialProps = GetMaterialProps( geometryProps ); // TODO: try to read metrials only if L1- and L2- lighting caches failed
            }

            //=============================================================================================================================================================
            // Hit point
            //=============================================================================================================================================================

            {
                //=============================================================================================================================================================
                // Lighting
                //=============================================================================================================================================================

                float4 Lcached = float4( materialProps.Lemi, 0.0 );
                if( !geometryProps.IsMiss( ) )
                {
                    // // L1 cache - reproject previous frame, carefully treating specular
                    // Lcached = GetRadianceFromPreviousFrame( geometryProps, materialProps, pixelPos );
                    //
                    // // L2 cache - SHARC
                    // HashGridParameters hashGridParams;
                    // hashGridParams.cameraPosition = gCameraGlobalPos.xyz;
                    // hashGridParams.sceneScale = SHARC_SCENE_SCALE;
                    // hashGridParams.logarithmBase = SHARC_GRID_LOGARITHM_BASE;
                    // hashGridParams.levelBias = SHARC_GRID_LEVEL_BIAS;
                    //
                    // float3 Xglobal = GetGlobalPos( geometryProps.X );
                    // uint level = HashGridGetLevel( Xglobal, hashGridParams );
                    // float voxelSize = HashGridGetVoxelSize( level, hashGridParams );
                    //
                    // float footprint = geometryProps.hitT * lobeTanHalfAngleAtOrigin * 2.0;
                    // float footprintNorm = saturate( footprint / voxelSize );
                    //
                    // float2 rndScaled = ImportanceSampling::Cosine::GetRay( Rng::Hash::GetFloat2( ) ).xy;
                    // rndScaled *= 1.0 - footprintNorm; // reduce dithering if cone is already wide
                    // rndScaled *= voxelSize;
                    // rndScaled *= USE_SHARC_DITHERING;
                    //
                    // float3x3 mBasis = Geometry::GetBasis( geometryProps.N );
                    // Xglobal += mBasis[ 0 ] * rndScaled.x + mBasis[ 1 ] * rndScaled.y;
                    //
                    // SharcHitData sharcHitData;
                    // sharcHitData.positionWorld = Xglobal;
                    // sharcHitData.materialDemodulation = GetMaterialDemodulation( geometryProps, materialProps );
                    // sharcHitData.normalWorld = geometryProps.N;
                    // sharcHitData.emissive = materialProps.Lemi;
                    //
                    // HashMapData hashMapData;
                    // hashMapData.capacity = SHARC_CAPACITY;
                    // hashMapData.hashEntriesBuffer = gInOut_SharcHashEntriesBuffer;
                    //
                    // SharcParameters sharcParams;
                    // sharcParams.gridParameters = hashGridParams;
                    // sharcParams.hashMapData = hashMapData;
                    // sharcParams.radianceScale = SHARC_RADIANCE_SCALE;
                    // sharcParams.enableAntiFireflyFilter = SHARC_ANTI_FIREFLY;
                    // sharcParams.accumulationBuffer = gInOut_SharcAccumulated;
                    // sharcParams.resolvedBuffer = gInOut_SharcResolved;
                    //
                    // bool isSharcAllowed = !geometryProps.Has( FLAG_HAIR ); // ignore if the hit is hair // TODO: if hair don't allow if hitT is too short
                    // isSharcAllowed &= Rng::Hash::GetFloat( ) > Lcached.w; // is needed?
                    // isSharcAllowed &= Rng::Hash::GetFloat( ) < ( bounce == gBounceNum ? 1.0 : footprintNorm ); // is voxel size acceptable?
                    // isSharcAllowed &= gSHARC && NRD_MODE < OCCLUSION; // trivial
                    //
                    // float3 sharcRadiance;
                    // if( isSharcAllowed && SharcGetCachedRadiance( sharcParams, sharcHitData, sharcRadiance, false ) )
                    //     Lcached = float4( sharcRadiance, 1.0 );
                    //
                    // // Cache miss - compute lighting, if not found in caches
                    // if( Rng::Hash::GetFloat( ) > Lcached.w )
                    {
                        float3 L = GetLighting( geometryProps, materialProps, LIGHTING | SHADOW ) + materialProps.Lemi;
                        Lcached.xyz = bounce < gBounceNum ? L : max( Lcached.xyz, L );
                    }
                }

                //=============================================================================================================================================================
                // Other
                //=============================================================================================================================================================

                // Accumulate lighting
                float3 L = Lcached.xyz * pathThroughput;
                Lsum += L;

                // ( Biased ) Reduce contribution of next samples if previous frame is sampled, which already has multi-bounce information
                pathThroughput *= 1.0 - Lcached.w;

                // Accumulate path length for NRD ( see "README/NOISY INPUTS" )
                float a = Color::Luminance( L );
                float b = Color::Luminance( Lsum ); // already includes L
                float importance = a / ( b + 1e-6 );

                importance *= 1.0 - Color::Luminance( materialProps.Lemi ) / ( a + 1e-6 );

                float diffuseLikeMotion = EstimateDiffuseProbability( geometryProps, materialProps, true );
                diffuseLikeMotion = isDiffuse ? 1.0 : diffuseLikeMotion;

                accumulatedHitDist += ApplyThinLensEquation( geometryProps.hitT, accumulatedCurvature ) * Math::SmoothStep( 0.2, 0.0, accumulatedDiffuseLikeMotion );
                accumulatedDiffuseLikeMotion += 1.0 - importance * ( 1.0 - diffuseLikeMotion );
                accumulatedCurvature += materialProps.curvature; // yes, after hit

            #if( USE_CAMERA_ATTACHED_REFLECTION_TEST == 1 && NRD_NORMAL_ENCODING == NRD_NORMAL_ENCODING_R10G10B10A2_UNORM )
                // IMPORTANT: lazy ( no checkerboard support ) implementation of reflections masking for objects attached to the camera
                // TODO: better find a generic solution for tracking of reflections for objects attached to the camera
                if( bounce == 1 && !isDiffuse && desc.materialProps.roughness < 0.01 )
                {
                    if( !geometryProps.IsMiss( ) && !geometryProps.Has( FLAG_STATIC ) )
                        gOut_Normal_Roughness[ desc.pixelPos ].w = MATERIAL_ID_SELF_REFLECTION;
                }
            #endif
            }
        }

        // Debug visualization: specular mip level at the end of the path
        if( gOnScreen == SHOW_MIP_SPECULAR )
        {
            float mipNorm = Math::Sqrt01( geometryProps.mip / MAX_MIP_LEVEL );
            Lsum = Color::ColorizeZucconi( mipNorm );
        }

        // Normalize hit distances for REBLUR before averaging ( needed only for AO for REFERENCE )
        float normHitDist = accumulatedHitDist;
        if( gDenoiserType != DENOISER_RELAX )
            normHitDist = REBLUR_FrontEnd_GetNormHitDist( accumulatedHitDist, viewZ0, gHitDistParams, isDiffusePath ? 1.0 : materialProps0.roughness );

        // Accumulate diffuse and specular separately for denoising
        if( !USE_SANITIZATION || NRD_IsValidRadiance( Lsum ) )
        {
            if( isDiffusePath )
            {
                result.diffRadiance += Lsum;
                result.diffHitDist += normHitDist;
                diffPathNum++;
            }
            else
            {
                result.specRadiance += Lsum;

            #if( NRD_MODE < OCCLUSION )
                NRD_FrontEnd_SpecHitDistAveraging_Add( result.specHitDist, normHitDist );
            #else
                result.specHitDist += normHitDist;
            #endif
            }
        }
    }

    // Material de-modulation ( convert irradiance into radiance )
    if( gOnScreen != SHOW_MIP_SPECULAR )
    {
        result.diffRadiance /= diffFactor0;
        result.specRadiance /= specFactor0;
    }

    // Radiance is already divided by sampling probability, we need to average across all paths
    float radianceNorm = 1.0 / float( gSampleNum );
    result.diffRadiance *= radianceNorm;
    result.specRadiance *= radianceNorm;

    // Others are not divided by sampling probability, we need to average across diffuse / specular only paths
    float diffNorm = diffPathNum == 0 ? 0.0 : 1.0 / float( diffPathNum );
    float specNorm = pathNum == diffPathNum ? 0.0 : 1.0 / float( pathNum - diffPathNum );

    result.diffHitDist *= diffNorm;

#if( NRD_MODE < OCCLUSION )
    NRD_FrontEnd_SpecHitDistAveraging_End( result.specHitDist );
#else
    result.specHitDist *= specNorm;
#endif

#if( NRD_MODE == SH || NRD_MODE == DIRECTIONAL_OCCLUSION )
    result.diffDirection *= diffNorm;
    result.specDirection *= specNorm;
#endif

    return result;
}





float3 Cover(float3 X)
{
    float3 n = float3(-X.r, -X.b, X.g);

    float3 normal = n * 0.5 + 0.5; // [-1,1] -> [0,1]

    return normal;
}

[numthreads(16,16,1)]
void CSMain(int2 pixelPos : SV_DispatchThreadID)
{
    float2 pixelUv = float2(pixelPos + 0.5) * gInvRectSize;
    float2 sampleUv = pixelUv + gJitter;

    if (pixelUv.x > 1.0 || pixelUv.y > 1.0)
    {
        #if( USE_DRS_STRESS_TEST == 1 )
        WriteResult(pixelPos, GARBAGE, GARBAGE, GARBAGE, GARBAGE);
        #endif

        return;
    }


    // Initialize RNG
    Rng::Hash::Initialize(pixelPos, gFrameIndex);

    //================================================================================================================================================================================
    // Primary ray
    //================================================================================================================================================================================
    
    float3 cameraRayOrigin = 0;
    float3 cameraRayDirection = 0;
    GetCameraRay(cameraRayOrigin, cameraRayDirection, sampleUv);

    GeometryProps geometryProps0 = CastRay(cameraRayOrigin, cameraRayDirection, 0.0, INF, GetConeAngleFromRoughness(0.0, 0.0), gWorldTlas, FLAG_NON_TRANSPARENT, 0);
    MaterialProps materialProps0 = GetMaterialProps(geometryProps0);
   
    //================================================================================================================================================================================
    // Primary surface replacement ( aka jump through mirrors )
    //================================================================================================================================================================================

    float3 psrThroughput = 1.0;
    float3x3 mirrorMatrix = Geometry::GetMirrorMatrix( 0 ); // identity
    float accumulatedHitDist = 0.0;
    float accumulatedCurvature = 0.0;
    uint bounceNum = PT_PSR_BOUNCES_NUM;

    float3 X0 = geometryProps0.X;
    float3 V0 = geometryProps0.V;
    float viewZ0 = -Geometry::AffineTransform( gWorldToView, geometryProps0.X ).z;

    
    bool isTaa5x5 = geometryProps0.Has( FLAG_HAIR | FLAG_SKIN ) || geometryProps0.IsMiss( ); // switched TAA to "higher quality & slower response" mode
    float viewZAndTaaMask0 = abs( viewZ0 ) * FP16_VIEWZ_SCALE * ( isTaa5x5 ? -1.0 : 1.0 );

    
    [loop]
    while( bounceNum && !geometryProps0.IsMiss( ) && IsDelta( materialProps0 ) && gPSR )
    {
        { // Origin point
            // Accumulate curvature
            accumulatedCurvature += materialProps0.curvature; // yes, before hit

            // Accumulate mirror matrix
            mirrorMatrix = mul( Geometry::GetMirrorMatrix( materialProps0.N ), mirrorMatrix );

            // Choose a ray
            float3 ray = reflect( -geometryProps0.V, materialProps0.N );

            // Update throughput
            float3 albedo, Rf0;
            BRDF::ConvertBaseColorMetalnessToAlbedoRf0( materialProps0.baseColor, materialProps0.metalness, albedo, Rf0 );

            float NoV = abs( dot( materialProps0.N, geometryProps0.V ) );
            float3 Fenv = BRDF::EnvironmentTerm_Rtg( Rf0, NoV, materialProps0.roughness );

            psrThroughput *= Fenv;

            // Trace to the next hit
            float2 mipAndCone = GetConeAngleFromRoughness( geometryProps0.mip, materialProps0.roughness );
            geometryProps0 = CastRay( geometryProps0.GetXoffset( geometryProps0.N ), ray, 0.0, INF, mipAndCone, gWorldTlas, FLAG_NON_TRANSPARENT, PT_RAY_FLAGS );
            materialProps0 = GetMaterialProps( geometryProps0 );
        }

        { // Hit point
            // Accumulate hit distance representing virtual point position ( see "README/NOISY INPUTS" )
            accumulatedHitDist += ApplyThinLensEquation( geometryProps0.hitT, accumulatedCurvature ) ; // TODO: take updated from NRD
        }

        bounceNum--;
    }

    
    //================================================================================================================================================================================
    // G-buffer ( guides )
    //================================================================================================================================================================================

    // Motion
    float3 Xvirtual = X0 - V0 * accumulatedHitDist;
    float3 XvirtualPrev = Xvirtual + geometryProps0.Xprev - geometryProps0.X;
    float3 motion = GetMotion( Xvirtual, XvirtualPrev );

    // gOut_Mv[ pixelPos ] = float4( motion, viewZAndTaaMask0 ); // IMPORTANT: keep viewZ before PSR ( needed for glass )

    // ViewZ
    float viewZ = -Geometry::AffineTransform( gWorldToView, Xvirtual ).z;
    viewZ = geometryProps0.IsMiss( ) ? Math::Sign( viewZ ) * INF : viewZ;

    // gOut_ViewZ[ pixelPos ] = viewZ;
    
    
    // Emission
    // gOut_DirectEmission[ pixelPos ] = materialProps0.Lemi * psrThroughput;

    
    // Early out
    if( geometryProps0.IsMiss( ) )
    {
        #if( USE_INF_STRESS_TEST == 1 )
        WriteResult( pixelPos, GARBAGE, GARBAGE, GARBAGE, GARBAGE );
        #endif

        return;
    }
    
    
    // Normal, roughness and material ID
    float3 N = Geometry::RotateVectorInverse( mirrorMatrix, materialProps0.N );
    
    float materialID = GetMaterialID( geometryProps0, materialProps0 );
    
    
    // gOut_Normal_Roughness[ pixelPos ] = NRD_FrontEnd_PackNormalAndRoughness( N, materialProps0.roughness, materialID );

    // Base color and metalness
    // gOut_BaseColor_Metalness[ pixelPos ] = float4( Color::ToSrgb( materialProps0.baseColor ), materialProps0.metalness );
    
    // Direct lighting
    float3 Xshadow;
    float3 Ldirect = GetLighting( geometryProps0, materialProps0, LIGHTING | SSS, Xshadow );

    // gOut_DirectLighting[ pixelPos ] = Ldirect; // "psrThroughput" applied in "Composition"
    // gOut_PsrThroughput[ pixelPos ] = psrThroughput;

    // Lighting at PSR hit, if found
    float4 Lpsr = 0;
    // if( !geometryProps0.IsMiss( ) && bounceNum != PT_PSR_BOUNCES_NUM )
    // {
    //     // L1 cache - reproject previous frame, carefully treating specular
    //     Lpsr = GetRadianceFromPreviousFrame( geometryProps0, materialProps0, pixelPos );
    //
    //     // Subtract direct lighting, process it separately
    //     float3 L = Ldirect * GetLighting( geometryProps0, materialProps0, SHADOW ) + materialProps0.Lemi;
    //     Lpsr.xyz = max( Lpsr.xyz - L, 0.0 );
    //
    //     // TODO: it's not a 100% fix
    //     if( gTracingMode == RESOLUTION_HALF && ( gIndirectDiffuse + gIndirectSpecular ) > 1.5 )
    //         Lpsr *= 0.5;
    //
    //     // This is important!
    //     Lpsr.xyz *= Lpsr.w;
    // }

    TraceOpaqueResult result = TraceOpaque( geometryProps0, materialProps0, pixelPos, mirrorMatrix, Lpsr );

    
    
 

    // float debugv = geometryProps0.instanceIndex / 4.0;

    // gOut_Debug[pixelPos] = float4( cameraRayDirection, 1.0 );

    // gOut_Debug[pixelPos] = float4(geometryProps0.uv, 0, 1.0);
    // gOut_Debug[pixelPos] = float4( 1,0,0, 1.0 );

    // float2 textureIds = pixelUv * 10;
    // int texIdFlat = int(int(textureIds.x) + int(textureIds.y) * 10);
    // texIdFlat = max(texIdFlat, 0);
    //

    // float c = sqrt( abs( materialProps0.curvature ) ) * 0.1;

    // gOut_Debug[pixelPos] =  float4( c, c, c, 1.0 );
    // gOut_Debug[pixelPos] = float4(materialProps0.curvature,materialProps0.curvature,materialProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(geometryProps0.curvature,geometryProps0.curvature,geometryProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(Cover(materialProps0.metalness), 1.0);
    gOut_Debug[pixelPos] = float4(result.diffRadiance, 1.0);
}
