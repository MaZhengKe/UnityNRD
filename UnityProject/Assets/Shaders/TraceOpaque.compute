#pragma use_dxc

#pragma require Int64BufferAtomics
#pragma require Native16Bit

#pragma kernel CSMain

#pragma require inlineraytracing
#pragma only_renderers d3d11

#include "Shared.hlsl"
#include "RaytracingShared.hlsl"


StructuredBuffer<uint4> gIn_ScramblingRanking;
StructuredBuffer<uint4> gIn_Sobol;


Texture2D<float3> gIn_PrevComposedDiff;
Texture2D<float4> gIn_PrevComposedSpec_PrevViewZ;

// 运动矢量（Motion Vector），用于描述像素在当前帧与上一帧之间的运动，以及视深（ViewZ）和TAA遮罩信息。
RWTexture2D<float4> gOut_Mv;
// 视空间深度（ViewZ），即像素在视空间中的Z值。
RWTexture2D<float> gOut_ViewZ;
// 法线、粗糙度和材质ID的打包信息。用于后续的去噪和材质区分。
RWTexture2D<float4> gOut_Normal_Roughness;
// 基础色（BaseColor，已转为sRGB）和金属度（Metalness）。
RWTexture2D<float4> gOut_BaseColor_Metalness;

// 直接光照（Direct Lighting），即主光线命中点的直接光照结果。
RWTexture2D<float3> gOut_DirectLighting;
// 直接自发光（Direct Emission），即材质的自发光分量。
RWTexture2D<float3> gOut_DirectEmission;

// 阴影数据（Shadow Data），如半影宽度等，用于软阴影和去噪。
RWTexture2D<float> gOut_ShadowData;
// 漫反射光照结果（Diffuse Radiance），包含噪声和打包后的信息。
RWTexture2D<float4> gOut_Diff;
// 高光反射光照结果（Specular Radiance），包含噪声和打包后的信息。
RWTexture2D<float4> gOut_Spec;



float2 GetBlueNoise( uint2 pixelPos, bool isCheckerboard, uint seed = 0 )
{
    // https://eheitzresearch.wordpress.com/772-2/
    // https://belcour.github.io/blog/research/publication/2019/06/17/sampling-bluenoise.html

    // Sample index
    uint frameIndex = isCheckerboard ? ( gFrameIndex >> 1 ) : gFrameIndex;
    uint sampleIndex = ( frameIndex + seed ) & ( BLUE_NOISE_TEMPORAL_DIM - 1 );

    uint2 uv = pixelPos & (BLUE_NOISE_SPATIAL_DIM - 1);
    uint index = uv.x + uv.y * BLUE_NOISE_SPATIAL_DIM;
    
    
    // The algorithm
    uint3 A = gIn_ScramblingRanking[ index ];
    uint rankedSampleIndex = sampleIndex ^ A.z;
    uint4 B = gIn_Sobol[ ( rankedSampleIndex & 255) ];
    float4 blue = ( float4( B ^ A.xyxy ) + 0.5 ) * ( 1.0 / 256.0 );

    // ( Optional ) Randomize in [ 0; 1 / 256 ] area to get rid of possible banding
    uint d = Sequence::Bayer4x4ui( pixelPos, gFrameIndex );
    float2 dither = ( float2( d & 3, d >> 2 ) + 0.5 ) * ( 1.0 / 4.0 );
    blue += ( dither.xyxy - 0.5 ) * ( 1.0 / 256.0 );

    // Don't use blue noise in these cases
    [flatten]
    if( gDenoiserType == DENOISER_REFERENCE || gRR || gTracingMode == RESOLUTION_FULL_PROBABILISTIC )
        blue.xy = Rng::Hash::GetFloat2( );

    return saturate( blue.xy );
}

struct TraceOpaqueResult
{
    float3 diffRadiance;
    float diffHitDist;

    float3 specRadiance;
    float specHitDist;
    
    
    float3 debug;

    #if( NRD_MODE == SH || NRD_MODE == DIRECTIONAL_OCCLUSION )
    float3 diffDirection;
    float3 specDirection;
    #endif
};


TraceOpaqueResult TraceOpaque( GeometryProps geometryProps0, MaterialProps materialProps0, uint2 pixelPos, float3x3 mirrorMatrix, float4 Lpsr )
{
    TraceOpaqueResult result = ( TraceOpaqueResult )0;
#if( NRD_MODE < OCCLUSION )
    result.specHitDist = NRD_FrontEnd_SpecHitDistAveraging_Begin( );
#endif

    float viewZ0 = Geometry::AffineTransform( gWorldToView, geometryProps0.X ).z;
    float roughness0 = materialProps0.roughness;

    // Material de-modulation ( convert irradiance into radiance )
    float3 diffFactor0, specFactor0;
    {
        float3 albedo, Rf0;
        BRDF::ConvertBaseColorMetalnessToAlbedoRf0( materialProps0.baseColor, materialProps0.metalness, albedo, Rf0 );

        NRD_MaterialFactors( materialProps0.N, geometryProps0.V, albedo, Rf0, materialProps0.roughness, diffFactor0, specFactor0 );

        // We can combine radiance ( for everything ) and irradiance ( for hair ) in denoising if material ID test is enabled
        if( geometryProps0.Has( FLAG_HAIR ) && NRD_NORMAL_ENCODING == NRD_NORMAL_ENCODING_R10G10B10A2_UNORM )
        {
            diffFactor0 = 1.0;
            specFactor0 = 1.0;
        }
    }

    // SHARC debug visualization
#if( USE_SHARC_DEBUG != 0 )
    HashGridParameters hashGridParams;
    hashGridParams.cameraPosition = gCameraGlobalPos.xyz;
    hashGridParams.sceneScale = SHARC_SCENE_SCALE;
    hashGridParams.logarithmBase = SHARC_GRID_LOGARITHM_BASE;
    hashGridParams.levelBias = SHARC_GRID_LEVEL_BIAS;

    SharcHitData sharcHitData;
    sharcHitData.positionWorld = GetGlobalPos( geometryProps0.X );
    sharcHitData.materialDemodulation = GetMaterialDemodulation( geometryProps0, materialProps0 );
    sharcHitData.normalWorld = geometryProps0.N;
    sharcHitData.emissive = materialProps0.Lemi;

    HashMapData hashMapData;
    hashMapData.capacity = SHARC_CAPACITY;
    hashMapData.hashEntriesBuffer = gInOut_SharcHashEntriesBuffer;

    SharcParameters sharcParams;
    sharcParams.gridParameters = hashGridParams;
    sharcParams.hashMapData = hashMapData;
    sharcParams.radianceScale = SHARC_RADIANCE_SCALE;
    sharcParams.enableAntiFireflyFilter = SHARC_ANTI_FIREFLY;
    sharcParams.accumulationBuffer = gInOut_SharcAccumulated;
    sharcParams.resolvedBuffer = gInOut_SharcResolved;

    #if( USE_SHARC_DEBUG == 2 )
        result.diffRadiance = HashGridDebugColoredHash( sharcHitData.positionWorld, hashGridParams );
    #else
        bool isValid = SharcGetCachedRadiance( sharcParams, sharcHitData, result.diffRadiance, true );

        // Highlight invalid cells
        // result.diffRadiance = isValid ?  result.diffRadiance : float3( 1.0, 0.0, 0.0 );
    #endif

    result.diffRadiance /= diffFactor0;

    return result;
#endif

    uint checkerboard = Sequence::CheckerBoard( pixelPos, gFrameIndex ) != 0;
    uint pathNum = gSampleNum << (gTracingMode == RESOLUTION_FULL ? 1 : 0);
    uint diffPathNum = 0;

    [loop]
    for( uint path = 0; path < pathNum; path++ )
    {
        GeometryProps geometryProps = geometryProps0;
        MaterialProps materialProps = materialProps0;

        float accumulatedHitDist = 0;
        float accumulatedDiffuseLikeMotion = 0;
        float accumulatedCurvature = 0;

        float3 Lsum = Lpsr.xyz;
        float3 pathThroughput = 1.0 - Lpsr.w;
        bool isDiffusePath = false;

        [loop]
        for( uint bounce = 1; bounce <= gBounceNum && !geometryProps.IsMiss( ); bounce++ )
        {
            //=============================================================================================================================================================
            // Origin point
            //=============================================================================================================================================================

            bool isDiffuse = false;
            float lobeTanHalfAngleAtOrigin = 0.0;
            {
                // Diffuse probability
                float diffuseProbability = EstimateDiffuseProbability( geometryProps, materialProps );

                float rnd = Rng::Hash::GetFloat( );
                if( gTracingMode == RESOLUTION_FULL_PROBABILISTIC && bounce == 1 && !gRR )
                {
                    // Clamp probability to a sane range to guarantee a sample in 3x3 ( or 5x5 ) area ( see NRD docs )
                    diffuseProbability = float( diffuseProbability != 0.0 ) * clamp( diffuseProbability, gMinProbability, 1.0 - gMinProbability );
                    rnd = Sequence::Bayer4x4( pixelPos, gFrameIndex ) + rnd / 16.0;
                }

                // Diffuse or specular?
                isDiffuse = rnd < diffuseProbability; // TODO: if "diffuseProbability" is clamped, "pathThroughput" should be adjusted too
                if( gTracingMode == RESOLUTION_FULL_PROBABILISTIC || bounce > 1 )
                    pathThroughput /= isDiffuse ? diffuseProbability : ( 1.0 - diffuseProbability );
                else
                    isDiffuse = gTracingMode == RESOLUTION_HALF ? checkerboard : ( path & 0x1 );

                // This is not needed in case of "RESOLUTION_FULL_PROBABILISTIC", since hair doesn't have diffuse component
                if( geometryProps.Has( FLAG_HAIR ) && isDiffuse )
                    break;

                // Importance sampling
                uint sampleMaxNum = 0;
                if( bounce == 1 && gDisableShadowsAndEnableImportanceSampling && NRD_MODE < OCCLUSION )
                    sampleMaxNum = PT_IMPORTANCE_SAMPLES_NUM * ( isDiffuse ? 1.0 : GetSpecMagicCurve( materialProps.roughness ) );
                sampleMaxNum = max( sampleMaxNum, 1 );

            #if( NRD_MODE < OCCLUSION )
                float2 rnd2 = Rng::Hash::GetFloat2( );
            #else
                uint2 blueNoisePos = pixelPos + uint2( Sequence::Weyl2D( 0.0, path * gBounceNum + bounce ) * ( BLUE_NOISE_SPATIAL_DIM - 1 ) );
                float2 rnd2 = GetBlueNoise( blueNoisePos, gTracingMode == RESOLUTION_HALF );
            #endif

                float3 ray = GenerateRayAndUpdateThroughput( geometryProps, materialProps, pathThroughput, sampleMaxNum, isDiffuse, rnd2, HAIR );

                // Special case for primary surface ( 1st bounce starts here )
                if( bounce == 1 )
                {
                    isDiffusePath = isDiffuse;

                    if( gTracingMode == RESOLUTION_FULL )
                        Lsum *= isDiffuse ? diffuseProbability : ( 1.0 - diffuseProbability );

                    // ( Optional ) Save sampling direction for the 1st bounce
                    #if( NRD_MODE == SH )
                        float3 psrRay = Geometry::RotateVectorInverse( mirrorMatrix, ray );

                        if( isDiffuse )
                            result.diffDirection += psrRay;
                        else
                            result.specDirection += psrRay;
                    #endif
                }

                // Abort tracing if the current bounce contribution is low
            #if( USE_RUSSIAN_ROULETTE == 1 )
                /*
                BAD PRACTICE:
                Russian Roulette approach is here to demonstrate that it's a bad practice for real time denoising for the following reasons:
                - increases entropy of the signal
                - transforms radiance into non-radiance, which is strictly speaking not allowed to be processed spatially (who wants to get a high energy firefly
                redistributed around surrounding pixels?)
                - not necessarily converges to the right image, because we do assumptions about the future and approximate the tail of the path via a scaling factor
                - this approach breaks denoising, especially REBLUR, which has been designed to work with pure radiance
                */

                // Nevertheless, RR can be used with caution: the code below tuned for good IQ / PERF tradeoff
                float russianRouletteProbability = Color::Luminance( pathThroughput );
                russianRouletteProbability = Math::Pow01( russianRouletteProbability, 0.25 );
                russianRouletteProbability = max( russianRouletteProbability, 0.01 );

                if( Rng::Hash::GetFloat( ) > russianRouletteProbability )
                    break;

                pathThroughput /= russianRouletteProbability;
            #else
                /*
                GOOD PRACTICE:
                - terminate path if "pathThroughput" is smaller than some threshold
                - approximate ambient at the end of the path
                - re-use data from the previous frame
                */

                if( PT_THROUGHPUT_THRESHOLD != 0.0 && Color::Luminance( pathThroughput ) < PT_THROUGHPUT_THRESHOLD )
                    break;
            #endif

                //=========================================================================================================================================================
                // Trace to the next hit
                //=========================================================================================================================================================

                float roughnessTemp = isDiffuse ? 1.0 : materialProps.roughness;
                lobeTanHalfAngleAtOrigin = roughnessTemp * roughnessTemp / ( 1.0 + roughnessTemp * roughnessTemp );

                float2 mipAndCone = GetConeAngleFromRoughness( geometryProps.mip, isDiffuse ? 1.0 : materialProps.roughness );
                geometryProps = CastRay( geometryProps.GetXoffset( geometryProps.N ), ray, 0.0, INF, mipAndCone, gWorldTlas, FLAG_NON_TRANSPARENT, PT_RAY_FLAGS );
                materialProps = GetMaterialProps( geometryProps ); // TODO: try to read metrials only if L1- and L2- lighting caches failed
            }

            //=============================================================================================================================================================
            // Hit point
            //=============================================================================================================================================================

            {
                //=============================================================================================================================================================
                // Lighting
                //=============================================================================================================================================================

                float4 Lcached = float4( materialProps.Lemi, 0.0 );
                if( !geometryProps.IsMiss( ) )
                {
                    // // L1 cache - reproject previous frame, carefully treating specular
                    // Lcached = GetRadianceFromPreviousFrame( geometryProps, materialProps, pixelPos );
                    //
                    // // L2 cache - SHARC
                    // HashGridParameters hashGridParams;
                    // hashGridParams.cameraPosition = gCameraGlobalPos.xyz;
                    // hashGridParams.sceneScale = SHARC_SCENE_SCALE;
                    // hashGridParams.logarithmBase = SHARC_GRID_LOGARITHM_BASE;
                    // hashGridParams.levelBias = SHARC_GRID_LEVEL_BIAS;
                    //
                    // float3 Xglobal = GetGlobalPos( geometryProps.X );
                    // uint level = HashGridGetLevel( Xglobal, hashGridParams );
                    // float voxelSize = HashGridGetVoxelSize( level, hashGridParams );
                    //
                    // float footprint = geometryProps.hitT * lobeTanHalfAngleAtOrigin * 2.0;
                    // float footprintNorm = saturate( footprint / voxelSize );
                    //
                    // float2 rndScaled = ImportanceSampling::Cosine::GetRay( Rng::Hash::GetFloat2( ) ).xy;
                    // rndScaled *= 1.0 - footprintNorm; // reduce dithering if cone is already wide
                    // rndScaled *= voxelSize;
                    // rndScaled *= USE_SHARC_DITHERING;
                    //
                    // float3x3 mBasis = Geometry::GetBasis( geometryProps.N );
                    // Xglobal += mBasis[ 0 ] * rndScaled.x + mBasis[ 1 ] * rndScaled.y;
                    //
                    // SharcHitData sharcHitData;
                    // sharcHitData.positionWorld = Xglobal;
                    // sharcHitData.materialDemodulation = GetMaterialDemodulation( geometryProps, materialProps );
                    // sharcHitData.normalWorld = geometryProps.N;
                    // sharcHitData.emissive = materialProps.Lemi;
                    //
                    // HashMapData hashMapData;
                    // hashMapData.capacity = SHARC_CAPACITY;
                    // hashMapData.hashEntriesBuffer = gInOut_SharcHashEntriesBuffer;
                    //
                    // SharcParameters sharcParams;
                    // sharcParams.gridParameters = hashGridParams;
                    // sharcParams.hashMapData = hashMapData;
                    // sharcParams.radianceScale = SHARC_RADIANCE_SCALE;
                    // sharcParams.enableAntiFireflyFilter = SHARC_ANTI_FIREFLY;
                    // sharcParams.accumulationBuffer = gInOut_SharcAccumulated;
                    // sharcParams.resolvedBuffer = gInOut_SharcResolved;
                    //
                    // bool isSharcAllowed = !geometryProps.Has( FLAG_HAIR ); // ignore if the hit is hair // TODO: if hair don't allow if hitT is too short
                    // isSharcAllowed &= Rng::Hash::GetFloat( ) > Lcached.w; // is needed?
                    // isSharcAllowed &= Rng::Hash::GetFloat( ) < ( bounce == gBounceNum ? 1.0 : footprintNorm ); // is voxel size acceptable?
                    // isSharcAllowed &= gSHARC && NRD_MODE < OCCLUSION; // trivial
                    //
                    // float3 sharcRadiance;
                    // if( isSharcAllowed && SharcGetCachedRadiance( sharcParams, sharcHitData, sharcRadiance, false ) )
                    //     Lcached = float4( sharcRadiance, 1.0 );
                    //
                    // // Cache miss - compute lighting, if not found in caches
                    // if( Rng::Hash::GetFloat( ) > Lcached.w )
                    {
                        float3 L = GetLighting( geometryProps, materialProps, LIGHTING | SHADOW ) + materialProps.Lemi;
                        Lcached.xyz = bounce < gBounceNum ? L : max( Lcached.xyz, L );
                    }
                }

                //=============================================================================================================================================================
                // Other
                //=============================================================================================================================================================

                // Accumulate lighting
                float3 L = Lcached.xyz * pathThroughput;
                Lsum += L;

                // ( Biased ) Reduce contribution of next samples if previous frame is sampled, which already has multi-bounce information
                pathThroughput *= 1.0 - Lcached.w;

                // Accumulate path length for NRD ( see "README/NOISY INPUTS" )
                float a = Color::Luminance( L );
                float b = Color::Luminance( Lsum ); // already includes L
                float importance = a / ( b + 1e-6 );

                importance *= 1.0 - Color::Luminance( materialProps.Lemi ) / ( a + 1e-6 );

                float diffuseLikeMotion = EstimateDiffuseProbability( geometryProps, materialProps, true );
                diffuseLikeMotion = isDiffuse ? 1.0 : diffuseLikeMotion;

                accumulatedHitDist += ApplyThinLensEquation( geometryProps.hitT, accumulatedCurvature ) * Math::SmoothStep( 0.2, 0.0, accumulatedDiffuseLikeMotion );
                accumulatedDiffuseLikeMotion += 1.0 - importance * ( 1.0 - diffuseLikeMotion );
                accumulatedCurvature += materialProps.curvature; // yes, after hit

            #if( USE_CAMERA_ATTACHED_REFLECTION_TEST == 1 && NRD_NORMAL_ENCODING == NRD_NORMAL_ENCODING_R10G10B10A2_UNORM )
                // IMPORTANT: lazy ( no checkerboard support ) implementation of reflections masking for objects attached to the camera
                // TODO: better find a generic solution for tracking of reflections for objects attached to the camera
                if( bounce == 1 && !isDiffuse && desc.materialProps.roughness < 0.01 )
                {
                    if( !geometryProps.IsMiss( ) && !geometryProps.Has( FLAG_STATIC ) )
                        gOut_Normal_Roughness[ desc.pixelPos ].w = MATERIAL_ID_SELF_REFLECTION;
                }
            #endif
            }
        }

        // Debug visualization: specular mip level at the end of the path
        if( gOnScreen == SHOW_MIP_SPECULAR )
        {
            float mipNorm = Math::Sqrt01( geometryProps.mip / MAX_MIP_LEVEL );
            Lsum = Color::ColorizeZucconi( mipNorm );
        }

        // Normalize hit distances for REBLUR before averaging ( needed only for AO for REFERENCE )
        float normHitDist = accumulatedHitDist;
        if( gDenoiserType != DENOISER_RELAX )
            normHitDist = REBLUR_FrontEnd_GetNormHitDist( accumulatedHitDist, viewZ0, gHitDistParams, isDiffusePath ? 1.0 : materialProps0.roughness );

        // Accumulate diffuse and specular separately for denoising
        if( !USE_SANITIZATION || NRD_IsValidRadiance( Lsum ) )
        {
            if( isDiffusePath )
            {
                result.diffRadiance += Lsum;
                result.diffHitDist += normHitDist;
                diffPathNum++;
            }
            else
            {
                result.specRadiance += Lsum;

            #if( NRD_MODE < OCCLUSION )
                NRD_FrontEnd_SpecHitDistAveraging_Add( result.specHitDist, normHitDist );
            #else
                result.specHitDist += normHitDist;
            #endif
            }
        }
    }

    // Material de-modulation ( convert irradiance into radiance )
    if( gOnScreen != SHOW_MIP_SPECULAR )
    {
        result.diffRadiance /= diffFactor0;
        result.specRadiance /= specFactor0;
    }

    // Radiance is already divided by sampling probability, we need to average across all paths
    float radianceNorm = 1.0 / float( gSampleNum );
    result.diffRadiance *= radianceNorm;
    result.specRadiance *= radianceNorm;

    // Others are not divided by sampling probability, we need to average across diffuse / specular only paths
    float diffNorm = diffPathNum == 0 ? 0.0 : 1.0 / float( diffPathNum );
    float specNorm = pathNum == diffPathNum ? 0.0 : 1.0 / float( pathNum - diffPathNum );

    result.diffHitDist *= diffNorm;

#if( NRD_MODE < OCCLUSION )
    NRD_FrontEnd_SpecHitDistAveraging_End( result.specHitDist );
#else
    result.specHitDist *= specNorm;
#endif

#if( NRD_MODE == SH || NRD_MODE == DIRECTIONAL_OCCLUSION )
    result.diffDirection *= diffNorm;
    result.specDirection *= specNorm;
#endif

    return result;
}





float3 Cover(float3 X)
{
    float3 n = float3(-X.r, -X.b, X.g);

    float3 normal = n * 0.5 + 0.5; // [-1,1] -> [0,1]

    return normal;
}


void WriteResult( uint2 pixelPos, float4 diff, float4 spec, float4 diffSh, float4 specSh )
{
    uint2 outPixelPos = pixelPos;
    if (gTracingMode == RESOLUTION_HALF)
        outPixelPos.x >>= 1;

    uint checkerboard = Sequence::CheckerBoard( pixelPos, gFrameIndex ) != 0;

    if( gTracingMode == RESOLUTION_HALF )
    {
        if( checkerboard )
        {
            gOut_Diff[ outPixelPos ] = diff;

            #if( NRD_MODE == SH )
            gOut_DiffSh[ outPixelPos ] = diffSh;
            #endif
        }
        else
        {
            gOut_Spec[ outPixelPos ] = spec;

            #if( NRD_MODE == SH )
            gOut_SpecSh[ outPixelPos ] = specSh;
            #endif
        }
    }
    else
    {
        gOut_Diff[ outPixelPos ] = diff;
        gOut_Spec[ outPixelPos ] = spec;

        #if( NRD_MODE == SH )
        gOut_DiffSh[ outPixelPos ] = diffSh;
        gOut_SpecSh[ outPixelPos ] = specSh;
        #endif
    }
}


[numthreads(16,16,1)]
void CSMain(int2 pixelPos : SV_DispatchThreadID)
{
    float2 pixelUv = float2(pixelPos + 0.5) * gInvRectSize;
    float2 sampleUv = pixelUv + gJitter;

    if (pixelUv.x > 1.0 || pixelUv.y > 1.0)
    {
        #if( USE_DRS_STRESS_TEST == 1 )
        WriteResult(pixelPos, GARBAGE, GARBAGE, GARBAGE, GARBAGE);
        #endif

        return;
    }


    // Initialize RNG
    Rng::Hash::Initialize(pixelPos, gFrameIndex);

    //================================================================================================================================================================================
    // Primary ray
    //================================================================================================================================================================================
    
    float3 cameraRayOrigin = 0;
    float3 cameraRayDirection = 0;
    GetCameraRay(cameraRayOrigin, cameraRayDirection, sampleUv);

    GeometryProps geometryProps0 = CastRay(cameraRayOrigin, cameraRayDirection, 0.0, INF, GetConeAngleFromRoughness(0.0, 0.0), gWorldTlas, FLAG_NON_TRANSPARENT, 0);
    MaterialProps materialProps0 = GetMaterialProps(geometryProps0);
   
    //================================================================================================================================================================================
    // Primary surface replacement ( aka jump through mirrors )
    //================================================================================================================================================================================

    float3 psrThroughput = 1.0;
    float3x3 mirrorMatrix = Geometry::GetMirrorMatrix( 0 ); // identity
    float accumulatedHitDist = 0.0;
    float accumulatedCurvature = 0.0;
    uint bounceNum = PT_PSR_BOUNCES_NUM;

    float3 X0 = geometryProps0.X;
    float3 V0 = geometryProps0.V;
    float viewZ0 = -Geometry::AffineTransform( gWorldToView, geometryProps0.X ).z;

    
    bool isTaa5x5 = geometryProps0.Has( FLAG_HAIR | FLAG_SKIN ) || geometryProps0.IsMiss( ); // switched TAA to "higher quality & slower response" mode
    float viewZAndTaaMask0 = abs( viewZ0 ) * FP16_VIEWZ_SCALE * ( isTaa5x5 ? -1.0 : 1.0 );

    
    // [loop]
    // while( bounceNum && !geometryProps0.IsMiss( ) && IsDelta( materialProps0 ) && gPSR )
    // {
    //     { // Origin point
    //         // Accumulate curvature
    //         accumulatedCurvature += materialProps0.curvature; // yes, before hit
    //
    //         // Accumulate mirror matrix
    //         mirrorMatrix = mul( Geometry::GetMirrorMatrix( materialProps0.N ), mirrorMatrix );
    //
    //         // Choose a ray
    //         float3 ray = reflect( -geometryProps0.V, materialProps0.N );
    //
    //         // Update throughput
    //         float3 albedo, Rf0;
    //         BRDF::ConvertBaseColorMetalnessToAlbedoRf0( materialProps0.baseColor, materialProps0.metalness, albedo, Rf0 );
    //
    //         float NoV = abs( dot( materialProps0.N, geometryProps0.V ) );
    //         float3 Fenv = BRDF::EnvironmentTerm_Rtg( Rf0, NoV, materialProps0.roughness );
    //
    //         psrThroughput *= Fenv;
    //
    //         // Trace to the next hit
    //         float2 mipAndCone = GetConeAngleFromRoughness( geometryProps0.mip, materialProps0.roughness );
    //         geometryProps0 = CastRay( geometryProps0.GetXoffset( geometryProps0.N ), ray, 0.0, INF, mipAndCone, gWorldTlas, FLAG_NON_TRANSPARENT, PT_RAY_FLAGS );
    //         materialProps0 = GetMaterialProps( geometryProps0 );
    //     }
    //
    //     { // Hit point
    //         // Accumulate hit distance representing virtual point position ( see "README/NOISY INPUTS" )
    //         accumulatedHitDist += ApplyThinLensEquation( geometryProps0.hitT, accumulatedCurvature ) ; // TODO: take updated from NRD
    //     }
    //
    //     bounceNum--;
    // }

    
    //================================================================================================================================================================================
    // G-buffer ( guides )
    //================================================================================================================================================================================

    // Motion
    float3 Xvirtual = X0 - V0 * accumulatedHitDist;
    float3 XvirtualPrev = Xvirtual + geometryProps0.Xprev - geometryProps0.X;
    float3 motion = GetMotion( Xvirtual, XvirtualPrev );

    gOut_Mv[ pixelPos ] = float4( motion, viewZAndTaaMask0 ); // IMPORTANT: keep viewZ before PSR ( needed for glass )

    // ViewZ
    float viewZ = -Geometry::AffineTransform( gWorldToView, Xvirtual ).z;
    viewZ = geometryProps0.IsMiss( ) ? Math::Sign( viewZ ) * INF : viewZ;

    gOut_ViewZ[ pixelPos ] = viewZ;
    
    
    // Emission
    gOut_DirectEmission[ pixelPos ] = materialProps0.Lemi * psrThroughput;

    
    // Early out
    if( geometryProps0.IsMiss( ) )
    {
        #if( USE_INF_STRESS_TEST == 1 )
        WriteResult( pixelPos, GARBAGE, GARBAGE, GARBAGE, GARBAGE );
        #endif

        return;
    }
    
    
    // Normal, roughness and material ID
    float3 N = Geometry::RotateVectorInverse( mirrorMatrix, materialProps0.N );
    
    float materialID = GetMaterialID( geometryProps0, materialProps0 );
    
    
    gOut_Normal_Roughness[ pixelPos ] = NRD_FrontEnd_PackNormalAndRoughness( N, materialProps0.roughness, materialID );

    // Base color and metalness
    // gOut_BaseColor_Metalness[ pixelPos ] = float4( Color::ToSrgb( materialProps0.baseColor ), materialProps0.metalness );
    // gOut_BaseColor_Metalness[ pixelPos ] = float4(  geometryProps0.instanceIndex / 1000.0 ,( geometryProps0.instanceIndex / 1000.0 ),geometryProps0.instanceIndex / 1000.0 , materialProps0.metalness );
    gOut_BaseColor_Metalness[ pixelPos ] = float4(  materialProps0.baseColor , materialProps0.metalness );
    
    // Direct lighting
    float3 Xshadow;
    float3 Ldirect = GetLighting( geometryProps0, materialProps0, LIGHTING | SSS, Xshadow );

    gOut_DirectLighting[ pixelPos ] = Ldirect; // "psrThroughput" applied in "Composition"
    // gOut_PsrThroughput[ pixelPos ] = psrThroughput;

    // Lighting at PSR hit, if found
    float4 Lpsr = 0;
    // if( !geometryProps0.IsMiss( ) && bounceNum != PT_PSR_BOUNCES_NUM )
    // {
    //     // L1 cache - reproject previous frame, carefully treating specular
    //     Lpsr = GetRadianceFromPreviousFrame( geometryProps0, materialProps0, pixelPos );
    //
    //     // Subtract direct lighting, process it separately
    //     float3 L = Ldirect * GetLighting( geometryProps0, materialProps0, SHADOW ) + materialProps0.Lemi;
    //     Lpsr.xyz = max( Lpsr.xyz - L, 0.0 );
    //
    //     // TODO: it's not a 100% fix
    //     if( gTracingMode == RESOLUTION_HALF && ( gIndirectDiffuse + gIndirectSpecular ) > 1.5 )
    //         Lpsr *= 0.5;
    //
    //     // This is important!
    //     Lpsr.xyz *= Lpsr.w;
    // }

    //================================================================================================================================================================================
    // Secondary rays
    //================================================================================================================================================================================

    TraceOpaqueResult result = TraceOpaque( geometryProps0, materialProps0, pixelPos, mirrorMatrix, Lpsr );

    #if( USE_MOVING_EMISSION_FIX == 1 )
    // Or emissives ( not having lighting in diffuse and specular ) can use a different material ID
    result.diffRadiance += materialProps0.Lemi / Math::Pi( 2.0 );
    result.specRadiance += materialProps0.Lemi / Math::Pi( 2.0 );
    #endif
    
 
    //================================================================================================================================================================================
    // Sun shadow
    //================================================================================================================================================================================

    geometryProps0.X = Xshadow;

    float2 rnd = GetBlueNoise( pixelPos, false );
    rnd = ImportanceSampling::Cosine::GetRay( rnd ).xy;
    rnd *= gTanSunAngularRadius;
    
    float3 sunDirection = normalize( gSunBasisX.xyz * rnd.x + gSunBasisY.xyz * rnd.y + gSunDirection.xyz );
    float3 Xoffset = geometryProps0.GetXoffset( sunDirection, PT_SHADOW_RAY_OFFSET );
    float2 mipAndCone = GetConeAngleFromAngularRadius( geometryProps0.mip, gTanSunAngularRadius );
    
    
    float shadowTranslucency = ( Color::Luminance( Ldirect ) != 0.0 && !gDisableShadowsAndEnableImportanceSampling ) ? 1.0 : 0.0;
    float shadowHitDist = 0.0;

    
    while( shadowTranslucency > 0.01 )
    {
        GeometryProps geometryPropsShadow = CastRay( Xoffset, sunDirection, 0.0, INF, mipAndCone, gWorldTlas, GEOMETRY_ALL, 0 );

        // Update hit dist
        shadowHitDist += geometryPropsShadow.hitT;

        // Terminate on miss ( before updating translucency! )
        if( geometryPropsShadow.IsMiss( ) )
            break;

        // ( Biased ) Cheap approximation of shadows through glass
        float NoV = abs( dot( geometryPropsShadow.N, sunDirection ) );
        shadowTranslucency *= lerp( geometryPropsShadow.Has( FLAG_TRANSPARENT ) ? 0.9 : 0.0, 0.0, Math::Pow01( 1.0 - NoV, 2.5 ) );

        // Go to the next hit
        Xoffset += sunDirection * ( geometryPropsShadow.hitT + 0.001 );
    }
    
    float penumbra = SIGMA_FrontEnd_PackPenumbra( shadowHitDist, gTanSunAngularRadius );
    
    
    gOut_ShadowData[ pixelPos ] = penumbra;
    

    //================================================================================================================================================================================
    // Output
    //================================================================================================================================================================================

    float4 outDiff = 0.0;
    float4 outSpec = 0.0;
    float4 outDiffSh = 0.0;
    float4 outSpecSh = 0.0;
    
    if( gDenoiserType == DENOISER_RELAX )
    {
        #if( NRD_MODE == SH )
        outDiff = RELAX_FrontEnd_PackSh( result.diffRadiance, result.diffHitDist, result.diffDirection, outDiffSh, USE_SANITIZATION );
        outSpec = RELAX_FrontEnd_PackSh( result.specRadiance, result.specHitDist, result.specDirection, outSpecSh, USE_SANITIZATION );
        #else
        outDiff = RELAX_FrontEnd_PackRadianceAndHitDist( result.diffRadiance, result.diffHitDist, USE_SANITIZATION );
        outSpec = RELAX_FrontEnd_PackRadianceAndHitDist( result.specRadiance, result.specHitDist, USE_SANITIZATION );
        #endif
    }
    else
    {
        #if( NRD_MODE == OCCLUSION )
        outDiff = result.diffHitDist;
        outSpec = result.specHitDist;
        #elif( NRD_MODE == SH )
        outDiff = REBLUR_FrontEnd_PackSh( result.diffRadiance, result.diffHitDist, result.diffDirection, outDiffSh, USE_SANITIZATION );
        outSpec = REBLUR_FrontEnd_PackSh( result.specRadiance, result.specHitDist, result.specDirection, outSpecSh, USE_SANITIZATION );
        #elif( NRD_MODE == DIRECTIONAL_OCCLUSION )
        outDiff = REBLUR_FrontEnd_PackDirectionalOcclusion( result.diffDirection, result.diffHitDist, USE_SANITIZATION );
        #else
        outDiff = REBLUR_FrontEnd_PackRadianceAndNormHitDist( result.diffRadiance, result.diffHitDist, USE_SANITIZATION );
        outSpec = REBLUR_FrontEnd_PackRadianceAndNormHitDist( result.specRadiance, result.specHitDist, USE_SANITIZATION );
        #endif
    }
    
    
    WriteResult( pixelPos, outDiff, outSpec, outDiffSh, outSpecSh );
}
