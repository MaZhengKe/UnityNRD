#pragma use_dxc

#pragma require Int64BufferAtomics
#pragma require Native16Bit

#pragma kernel CSMain

#pragma require inlineraytracing
#pragma only_renderers d3d11

#include "Shared.hlsl"
#include "RaytracingShared.hlsl"


RWTexture2D<float4> gOut_Debug;


[numthreads(16,16,1)]
void CSMain(int2 pixelPos : SV_DispatchThreadID)
{
    float2 pixelUv = float2(pixelPos + 0.5) * gInvRectSize;
    float2 sampleUv = pixelUv + gJitter;

    if (pixelUv.x > 1.0 || pixelUv.y > 1.0)
    {
        return;
    }


    Rng::Hash::Initialize(pixelPos, gFrameIndex);

    float3 cameraRayOrigin = 0;
    float3 cameraRayDirection = 0;
    GetCameraRay(cameraRayOrigin, cameraRayDirection, sampleUv);

    GeometryProps geometryProps0 = CastRay(cameraRayOrigin, cameraRayDirection, 0.0, INF, GetConeAngleFromRoughness(0.0, 0.0), gWorldTlas, 0xFF, RAY_FLAG_CULL_NON_OPAQUE);
    MaterialProps materialProps0 = GetMaterialProps(geometryProps0);


    bool isMiss = geometryProps0.IsMiss();

    if (isMiss)
        return;

    // float debugv = geometryProps0.instanceIndex / 4.0;

    // gOut_Debug[pixelPos] = float4( cameraRayDirection, 1.0 );

    gOut_Debug[pixelPos] = float4(geometryProps0.uv, 0, 1.0);
    // gOut_Debug[pixelPos] = float4( 1,0,0, 1.0 );

    // float2 textureIds = pixelUv * 10;
    // int texIdFlat = int(int(textureIds.x) + int(textureIds.y) * 10);
    // texIdFlat = max(texIdFlat, 0);
    //


    // gOut_Debug[pixelPos] = float4(materialProps0.curvature,materialProps0.curvature,materialProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(geometryProps0.curvature,geometryProps0.curvature,geometryProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(materialProps0.N, 1.0);
}
