#pragma use_dxc 

// #pragma require Int64BufferAtomics
// #pragma require Native16Bit

#pragma kernel CSMain

#pragma require inlineraytracing
#pragma only_renderers d3d11

#include "RayPayload.hlsl"

struct PrimitiveData
{
    float2 uv0;
    float2 uv1;
    float2 uv2;
    float worldArea;

    float2 n0;
    float2 n1;
    float2 n2;
    float uvArea;

    float2 t0;
    float2 t1;
    float2 t2;
    float bitangentSign;
};

struct InstanceData
{
    // For static: mObjectToWorld
    // For dynamic: mWorldToWorldPrev
    float4x4 mObjectToWorld;

    float4 baseColorAndMetalnessScale;
    float4 emissionAndRoughnessScale;

    float2 normalUvScale;
    uint textureOffsetAndFlags;
    uint primitiveOffset;
    float scale; // TODO: handling object scale embedded into the transformation matrix (assuming uniform scale), sign represents triangle winding

    uint morphPrimitiveOffset;
    uint unused1;
    uint unused2;
    uint unused3;
};




RWTexture2D<float4> gOut_Debug;

Texture2D gIn_Textures[] : register(t31);
SamplerState my_linear_clamp_sampler;
SamplerState my_linear_repeat_sampler;



void GetCameraRay(out float3 origin, out float3 direction, float2 sampleUv)
{
    // https://www.slideshare.net/TiagoAlexSousa/graphics-gems-from-cryengine-3-siggraph-2013 ( slides 23+ )

    // Pinhole ray
    float3 Xv = Geometry::ReconstructViewPosition(sampleUv, gCameraFrustum, gNearZ);
    direction = normalize(Xv);

    // Distorted ray
    float2 rnd = Rng::Hash::GetFloat2();
    rnd = ImportanceSampling::Cosine::GetRay(rnd).xy;
    Xv.xy += rnd * gAperture;

    float3 Fv = direction * gFocalDistance; // z-plane
    #if 0
    Fv /= dot(vForward, direction); // radius
    #endif

    origin = Geometry::AffineTransform(gViewToWorld, Xv);
    direction = normalize(Geometry::RotateVector(gViewToWorld, Fv - Xv));
}


float2 GetConeAngleFromAngularRadius(float mip, float tanConeAngle)
{
    // In any case, we are limited by the output resolution
    tanConeAngle = max(tanConeAngle, gTanPixelAngularRadius);

    return float2(mip, tanConeAngle);
}


float2 GetConeAngleFromRoughness(float mip, float roughness)
{
    float tanConeAngle = roughness * roughness * 0.05; // TODO: tweaked to be accurate and give perf boost

    return GetConeAngleFromAngularRadius(mip, tanConeAngle);
}


#define MAX_MIP_LEVEL                       11.0

GeometryProps CastRay( float3 origin, float3 direction, float Tmin, float Tmax, float2 mipAndCone, RaytracingAccelerationStructure accelerationStructure, uint instanceInclusionMask, uint rayFlags )
{
    RayDesc rayDesc;
    rayDesc.Origin = origin;
    rayDesc.Direction = direction;
    rayDesc.TMin = Tmin;
    rayDesc.TMax = Tmax;

    RayQuery< RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES > rayQuery;
    rayQuery.TraceRayInline( accelerationStructure, rayFlags, instanceInclusionMask, rayDesc );
    
    rayQuery.Proceed( );
    
    GeometryProps props = ( GeometryProps )0;
    props.mip = mipAndCone.x;
    
    if( rayQuery.CommittedStatus( ) == COMMITTED_NOTHING )
    {
        props.hitT = INF;
        props.X = origin + direction * props.hitT;
        props.Xprev = props.X;
    }
    else
    {
        props.hitT = rayQuery.CommittedRayT( );
        
        // Instance
        uint instanceIndex = rayQuery.CommittedInstanceID( ) + rayQuery.CommittedGeometryIndex( );
        props.instanceIndex = instanceIndex;
        
        InstanceData instanceData = gIn_InstanceData[ instanceIndex ];
        
        // Texture offset and flags
        props.textureOffsetAndFlags = instanceData.textureOffsetAndFlags;
        
        // Transform
        float3x3 mObjectToWorld = ( float3x3 )rayQuery.CommittedObjectToWorld3x4( );
        float3x4 mOverloaded = (float3x4)( instanceData.mObjectToWorld); 
        
        mObjectToWorld = ( float3x3 )mOverloaded;
        
        float flip = Math::Sign( instanceData.scale ) * ( rayQuery.CommittedTriangleFrontFace( ) ? -1.0 : 1.0 );
        
        
        // Primitive
        uint primitiveIndex = instanceData.primitiveOffset + rayQuery.CommittedPrimitiveIndex( );
        PrimitiveData primitiveData = gIn_PrimitiveData[ primitiveIndex ];
        
        
        float worldArea = primitiveData.worldArea * instanceData.scale * instanceData.scale;
        
        
        // Barycentrics
        float3 barycentrics;
        barycentrics.yz = rayQuery.CommittedTriangleBarycentrics( );
        barycentrics.x = 1.0 - barycentrics.y - barycentrics.z;

        // Normal
        float3 n0 = Packing::DecodeUnitVector( primitiveData.n0, true );
        float3 n1 = Packing::DecodeUnitVector( primitiveData.n1, true );
        float3 n2 = Packing::DecodeUnitVector( primitiveData.n2, true );

        float3 N = barycentrics.x * n0 + barycentrics.y * n1 + barycentrics.z * n2;
        N = Geometry::RotateVector( mObjectToWorld, N );
        N = normalize( N * flip );
        props.N = -N; // TODO: why negated?
        
        
        // Curvature
        float dnSq0 = Math::LengthSquared( n0 - n1 );
        float dnSq1 = Math::LengthSquared( n1 - n2 );
        float dnSq2 = Math::LengthSquared( n2 - n0 );
        float dnSq = max( dnSq0, max( dnSq1, dnSq2 ) );
        props.curvature = sqrt( dnSq / worldArea );

        // Mip level
        float NoRay = abs( dot( direction, props.N ) );
        float a = props.hitT * mipAndCone.y;
        a *= Math::PositiveRcp( NoRay );
        a *= sqrt( primitiveData.uvArea / worldArea );

        float mip = log2( a );
        mip += MAX_MIP_LEVEL;
        mip = max( mip, 0.0 );
        props.mip += mip;

        // Uv
        props.uv = barycentrics.x * primitiveData.uv0 + barycentrics.y * primitiveData.uv1 + barycentrics.z * primitiveData.uv2;

        // Tangent
        float3 t0 = Packing::DecodeUnitVector( primitiveData.t0, true );
        float3 t1 = Packing::DecodeUnitVector( primitiveData.t1, true );
        float3 t2 = Packing::DecodeUnitVector( primitiveData.t2, true );
        
        
        float3 T = barycentrics.x * t0 + barycentrics.y * t1 + barycentrics.z * t2;
        T = Geometry::RotateVector( mObjectToWorld, T );
        T = normalize( T );
        props.T = float4( T, primitiveData.bitangentSign );

        props.X = origin + direction * props.hitT;
        
        props.Xprev = props.X;
        
    }
    
    props.V = -direction;
    
    return props;
}

#define MAX_MIP_LEVEL                       11.0

// Mip mode
#define MIP_VISIBILITY                      0 // for visibility: emission, shadow and alpha mask
#define MIP_LESS_SHARP                      1 // for normal
#define MIP_SHARP                           2 // for albedo and roughness


float3 GetSamplingCoords( uint textureIndex, float2 uv, float mip, int mode )
{
    float2 texSize;
    gIn_Textures[ NonUniformResourceIndex( textureIndex ) ].GetDimensions( texSize.x, texSize.y ); // TODO: if I only had it as a constant...

    // Recalculate for the current texture
    float mipNum = log2( max( texSize.x, texSize.y ) );
    mip += mipNum - MAX_MIP_LEVEL;
    if( mode == MIP_VISIBILITY )
    {
        // We must avoid using lower mips because it can lead to significant increase in AHS invocations. Mips lower than 128x128 are skipped!
        mip = min( mip, mipNum - 7.0 );
    }
    else
        // mip += gMipBias * ( mode == MIP_LESS_SHARP ? 0.5 : 1.0 );
        mip += 1 * ( mode == MIP_LESS_SHARP ? 0.5 : 1.0 );
    mip = clamp( mip, 0.0, mipNum - 1.0 );

    #if( USE_STOCHASTIC_SAMPLING == 1 )
    mip = floor( mip ) + step( Rng::Hash::GetFloat( ), frac( mip ) );
    #elif( USE_LOAD == 1 )
    mip = round( mip );
    #endif

    texSize *= exp2( -mip );

    // Uv coordinates
    #if( USE_STOCHASTIC_SAMPLING == 1 )
    uv = STF_Bilinear( uv, texSize );
    #endif

    #if( USE_LOAD == 1 )
    uv = frac( uv ) * texSize;
    #endif

    return float3( uv, mip );
}

#define TEX_SAMPLER my_linear_repeat_sampler

#define SAMPLE( coords ) SampleLevel( TEX_SAMPLER, coords.xy, coords.z )

MaterialProps GetMaterialProps( GeometryProps geometryProps )
{
    MaterialProps props = ( MaterialProps )0;

    // Fast path for miss and hair
    [branch]
    if( geometryProps.IsMiss( ) )
    {
        props.Lemi = GetSkyIntensity( -geometryProps.V );

        return props;
    }
#if( RTXCR_INTEGRATION == 1 )
    else if( geometryProps.Has( FLAG_HAIR ) )
    {
        props.N = geometryProps.N;
        props.T = geometryProps.T.xyz;
        props.baseColor = gHairBaseColor.xyz * 0.25; // TODO: still not the best match in terms of energy
        props.roughness = gHairBetas.x;
        props.curvature = geometryProps.curvature;
        props.metalness = 1.0; // no diffuse lobe for hair

        return props;
    }
#endif

    uint baseTexture = geometryProps.GetBaseTexture( );
    InstanceData instanceData = gIn_InstanceData[ geometryProps.instanceIndex ];

    // Base color
    float3 coords = GetSamplingCoords( baseTexture, geometryProps.uv, geometryProps.mip, MIP_SHARP );
    float4 color = gIn_Textures[ NonUniformResourceIndex( baseTexture ) ].SAMPLE( coords );
    color.xyz *= instanceData.baseColorAndMetalnessScale.xyz;
    color.xyz *= geometryProps.Has( FLAG_TRANSPARENT ) ? 1.0 : Math::PositiveRcp( color.w ); // Correct handling of BC1 with pre-multiplied alpha
    float3 baseColor = saturate( color.xyz );

    // Roughness and metalness
    coords = GetSamplingCoords( baseTexture + 1, geometryProps.uv, geometryProps.mip, MIP_SHARP );
    float3 materialProps = gIn_Textures[ NonUniformResourceIndex( baseTexture + 1 ) ].SAMPLE( coords ).xyz;
    float roughness = saturate( materialProps.g * instanceData.emissionAndRoughnessScale.w );
    float metalness = saturate( materialProps.b * instanceData.baseColorAndMetalnessScale.w );

    // Normal
    coords = GetSamplingCoords( baseTexture + 2, geometryProps.uv * instanceData.normalUvScale, geometryProps.mip, MIP_LESS_SHARP );
    float2 packedNormal = gIn_Textures[ NonUniformResourceIndex( baseTexture + 2 ) ].SAMPLE( coords ).xy;
    float3 N =  Geometry::TransformLocalNormal( packedNormal, geometryProps.T, geometryProps.N ) ;
    float3 T = geometryProps.T.xyz;

    // Estimate curvature
    float viewZ = Geometry::AffineTransform( gWorldToView, geometryProps.X ).z;
    float pixelSize = gUnproject * lerp( abs( viewZ ), 1.0, abs( 0 ) );
    float localCurvature = length( Geometry::UnpackLocalNormal( packedNormal ).xy );
    localCurvature /= pixelSize;

    // Emission
    coords = GetSamplingCoords( baseTexture + 3, geometryProps.uv, geometryProps.mip, MIP_VISIBILITY );
    float3 Lemi = gIn_Textures[ NonUniformResourceIndex( baseTexture + 3 ) ].SAMPLE( coords ).xyz;
    Lemi *= instanceData.emissionAndRoughnessScale.xyz;
    Lemi *= ( baseColor + 0.01 ) / ( max( baseColor, max( baseColor, baseColor ) ) + 0.01 );

    [flatten]
    if( geometryProps.Has( FLAG_FORCED_EMISSION ) )
    {
        Lemi = geometryProps.GetForcedEmissionColor( );
        baseColor = 0.0;
    }

    Lemi *= 1;
 

    #if( USE_PUDDLES == 1 )
        roughness *= Math::SmoothStep( 0.6, 0.8, length( frac( geometryProps.uv ) * 2.0 - 1.0 ) );
    #endif

    #if( USE_RANDOMIZED_ROUGHNESS == 1 )
        float2 noise = ( frac( sin( dot( geometryProps.uv, float2( 12.9898, 78.233 ) * 2.0 ) ) * 43758.5453 ) );
        float noise01 = abs( noise.x + noise.y ) * 0.5;
        roughness *= 1.0 + ( noise01 * 2.0 - 1.0 ) * 0.25;
    #endif

    roughness = saturate( roughness );
    metalness = saturate( metalness );

    // Transform to diffuse material if emission is here
    float emissionLevel = Color::Luminance( Lemi );
    emissionLevel = saturate( emissionLevel * 50.0 );

    metalness = lerp( metalness, 0.0, emissionLevel );
    roughness = lerp( roughness, 1.0, emissionLevel );

    props.Lemi = Lemi;
    props.N = N;
    props.T = T;
    props.baseColor = baseColor;
    props.roughness = roughness;
    props.metalness = metalness;
    props.curvature = geometryProps.curvature + localCurvature;

    return props;
}

[numthreads(16,16,1)]
void CSMain(int2 pixelPos : SV_DispatchThreadID)
{
    float2 pixelUv = float2( pixelPos + 0.5 ) * gInvRectSize;
    float2 sampleUv = pixelUv + gJitter;
    
    if( pixelUv.x > 1.0 || pixelUv.y > 1.0 )
    {
        return;
    }
    
    
    Rng::Hash::Initialize( pixelPos, gFrameIndex );
    
    float3 cameraRayOrigin = 0;
    float3 cameraRayDirection = 0;
    GetCameraRay( cameraRayOrigin, cameraRayDirection, sampleUv );
    
    GeometryProps geometryProps0 = CastRay( cameraRayOrigin, cameraRayDirection, 0.0, INF, GetConeAngleFromRoughness( 0.0, 0.0 ), gWorldTlas, 0xFF, RAY_FLAG_CULL_NON_OPAQUE );
    MaterialProps materialProps0 = GetMaterialProps( geometryProps0 );
    
    
    bool isMiss = geometryProps0.IsMiss();
    
    if (isMiss )
        return;
    
    // float debugv = geometryProps0.instanceIndex / 4.0;
    
    // gOut_Debug[pixelPos] = float4( cameraRayDirection, 1.0 );
    
    gOut_Debug[pixelPos] = float4( geometryProps0.uv,0, 1.0 );
    // gOut_Debug[pixelPos] = float4( 1,0,0, 1.0 );
    
    // float2 textureIds = pixelUv * 10;
    // int texIdFlat = int(int(textureIds.x) + int(textureIds.y) * 10);
    // texIdFlat = max(texIdFlat, 0);
    //
     

    // gOut_Debug[pixelPos] = float4(materialProps0.curvature,materialProps0.curvature,materialProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(geometryProps0.curvature,geometryProps0.curvature,geometryProps0.curvature, 1.0);
    // gOut_Debug[pixelPos] = float4(materialProps0.N, 1.0);
}